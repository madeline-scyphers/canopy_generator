import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from canopy_types import ForestCanopy_data
from plotting import plot_heatmap, plot_surface
from utils import get_stem_diam_and_breast_height, Generate_PatchMap, make_can_gen_rand_field


nx = 250 # #grid points east-west
ny = 250  # grid points south-north
Dx = 5.0  # horizontal grid-mesh size [m]. LoadCanopy_Profiles.m assumes Dx==Dy, this can be easily modified
Dy = Dx
Dz = 3.0  # vertical grid-mesh size [m], needed to find the highest point in the canopy, in terms of # grid-points, which is sometimes used to dimensionalize input arrays in a program that might use this canopy

# Landscape parameters:
L = 10.0  # length-scale of discontinuity [m] that characterizes patch-type distribution (regioal lenght-scale)

# patch params
# PatchCutOff=np.array([0.9, 0.1]) # vector- portion of the area with each patch type -in this example; 90% Spring hardwood, 10% grass; Must total to 1!!!
# patchtype=np.array([4, 2]) # patch type code to patch canopy properties data in ForestCanopy_data.m
# # The user should add his/her patch types in ForestCanopy_data.m, as needed for their symulations and as observed in their environments

PatchCutOff = np.array(
    [0.9, 0.1]
)  # vector- portion of the area with each patch type -in this example; 90% Spring hardwood, 10% grass; Must total to 1!!!
patchtype = np.array([1, 2])  # patch type code to patch canopy properties data in ForestCanopy_data.m
# The user should add his/he

# other params:
filepath = "./OutFiles/"
# path to location of output files


def generate_canopy():
    global PatchCutOff
    # Domain parameters:

    # *******************************************************************

    # Basic housekeeping
    # rand('state',sum(100*clock)); # randomize
    npatch = len(patchtype)
    # determine number of patch types

    # normalized PatchCutOff and convert to accumulated area
    PatchCutOff = PatchCutOff / sum(PatchCutOff)
    if npatch > 1:
        for p in range(1, npatch):  # p=2:npatch
            PatchCutOff[p] = PatchCutOff[p - 1] + PatchCutOff[p]

    # build meshed-grid
    # x = np.arange(nx) * Dx
    # y = np.arange(ny) * Dy
    x = np.arange(-(nx-1)/2,(nx - 1)/2 + 1)*Dx
    y = np.arange(-(ny-1)/2,(ny- 1)/2 + 1)*Dy
    X, Y = np.meshgrid(x, y)

    StandDenc = np.zeros((npatch, 1))
    HDBHpar = np.zeros((npatch, 3))

    if npatch > 1:
        # Generate landscape map of patches
        AcF = np.exp(
            -(1 / L) * (X ** 2 + Y ** 2) ** 0.5
        )  # regional (patch level) autocorrelation function. Could be replaced by an observed auto-correlation function, or patch type map
        lambda_r = make_can_gen_rand_field(nx, ny, AcF)
        patch = Generate_PatchMap(patchtype, lambda_r, ny, nx, PatchCutOff, npatch)

        # Allocate canopy properties params - These will be read by ForestCanopy_data
        avg_lai = np.zeros((npatch, 1))
        avgH = np.zeros((npatch, 1))
        sig_lai = np.zeros((npatch, 1))
        sigH = np.zeros((npatch, 1))
        avg_flux = np.zeros((npatch, 1))
        sig_flux = np.zeros((npatch, 1))
        avg_albedo = np.zeros((npatch, 1))
        sig_albedo = np.zeros((npatch, 1))
        bowen_ratio = np.zeros((npatch, 1))
        sig_bowen = np.zeros((npatch, 1))

        # Allocate canopy field variables - These are sets of fields with canopy properties per patch type. each fills the entire domains.
        # Each field will be cut and put together according to the landscape patch.
        #  each set of fields that are associated with one patch are covarying,
        #  and generated by normalization of a single, path level random filed
        #  (lambdap). The canopy properties params are used for these
        #  normalizations
        CSProf = np.zeros((npatch, 101))
        LAD = np.zeros((npatch, 101))
        AcF = np.zeros((ny, nx, npatch))
        lambdap = np.zeros((ny, nx, npatch))
        TotLAI = np.zeros((ny, nx, npatch))
        Height = np.zeros((ny, nx, npatch))
        Bowen = np.zeros((ny, nx, npatch))
        TotFlux = np.zeros((ny, nx, npatch))
        Albedo = np.zeros((ny, nx, npatch))

        # generate a random canopy field for each patch type
        for z in range(npatch):
            canopy = ForestCanopy_data(patchtype[z], nx, Dx, ny, Dy)
            (
                CSProf[z, :],
                HDBHpar[z, :],
                LAD[z, :],
                zcm,
                avg_lai[z],
                avgH[z],
                sig_lai[z],
                sigH[z],
                avg_flux[z],
                sig_flux[z],
                avg_albedo[z],
                sig_albedo[z],
                bowen_ratio[z],
                sig_bowen[z],
                StandDenc[z],
                AcF[:, :, z],
            ) = canopy.export()
            # rand('state',sum(100*clock))  # randomize
            lambdap[:, :, z] = make_can_gen_rand_field(nx, ny, AcF[:, :, z])

            # xvec=reshape(lambdap(:,:,z),[nx*ny 1]);
            std = lambdap.std()
            mu = lambdap.mean()

            # scale by mean and std
            l_minus_mean = lambdap[:, :, z] - mu
            if std == 0:
                TotLAI[:, :, z] = np.maximum(0, (l_minus_mean + avg_lai[z]))
                Height[:, :, z] = np.maximum(0, (l_minus_mean + avgH[z]))

                Bowen[:, :, z] = np.maximum(0, (l_minus_mean + bowen_ratio[z]))
                TotFlux[:, :, z] = np.maximum(0, (l_minus_mean + avg_flux[z]))
                Albedo[:, :, z] = np.maximum(0, (l_minus_mean + avg_albedo[z]))
            else:
                TotLAI[:, :, z] = np.maximum(0, (l_minus_mean * (sig_lai[z] / std) + avg_lai[z]))
                Height[:, :, z] = np.maximum(0, (l_minus_mean * (sigH[z] / std) + avgH[z]))

                Bowen[:, :, z] = np.maximum(0, (l_minus_mean * (sig_bowen[z] / std) + bowen_ratio[z]))
                TotFlux[:, :, z] = np.maximum(0, (l_minus_mean * (sig_flux[z] / std) + avg_flux[z]))
                Albedo[:, :, z] = np.maximum(0, (l_minus_mean * (sig_albedo[z] / std) + avg_albedo[z]))

        # compose a combined canopy usiing landscape patch map
        TotLAIc = np.zeros((ny, nx))
        Heightc = np.zeros((ny, nx))

        Bowenc = np.zeros((ny, nx))
        TotFluxc = np.zeros((ny, nx))
        Albedoc = np.zeros((ny, nx))

        for xp in range(nx):
            for yp in range(ny):
                TotLAIc[yp, xp] = TotLAI[yp, xp, patch[yp, xp]]
                Heightc[yp, xp] = Height[yp, xp, patch[yp, xp]]
                Bowenc[yp, xp] = Bowen[yp, xp, patch[yp, xp]]
                TotFluxc[yp, xp] = TotFlux[yp, xp, patch[yp, xp]]
                Albedoc[yp, xp] = Albedo[yp, xp, patch[yp, xp]]

    else:
        patch = np.ones((ny, nx))
        canopy = ForestCanopy_data(patchtype[0], nx, Dx, ny, Dy)
        StandDenc[0] = canopy.stand_density
        HDBHpar[0, :] = canopy.HDBHpar
        lambdap = make_can_gen_rand_field(nx, ny, canopy.AcF)

        std = lambdap.std()
        mu = lambdap.mean()

        # re-scale by mean and variance
        TotLAIc = np.maximum(0, ((lambdap - mu) * (canopy.sig_lai / std) + canopy.avg_lai))
        Heightc = np.maximum(0, ((lambdap - mu) * (canopy.sigH / std) + canopy.avgH))
        Bowenc = np.maximum(0, ((lambdap - mu) * (canopy.sig_bowen / std) + canopy.bowen_ratio))
        TotFluxc = np.maximum(0, ((lambdap - mu) * (canopy.sig_flux / std) + canopy.avg_flux))
        Albedoc = np.maximum(0, ((lambdap - mu) * (canopy.sig_albedo / std) + canopy.avg_albedo))

    DBHc = get_stem_diam_and_breast_height(patch, HDBHpar, Heightc, nx, Dx, ny, Dy, StandDenc, npatch)

    Hmax = Heightc.max()
    zRi = Hmax // Dz + 2  # number of vertical grid points in the canopy domain +1
    dims_pzRyx = [npatch, len(canopy.zcm), zRi, *TotLAIc.shape, 0.0]

    canopy.CSProfile = canopy.CSProfile.T
    canopy.LAD = canopy.LAD.T
    canopy.zcm = canopy.zcm.T

    plot_heatmap(TotLAIc, x=x, y=y, title="Total Lai")
    plot_heatmap(Heightc, x=x, y=y, title="Height")
    plot_surface(x=X, y=Y, z=Heightc, title="Height")
    plot_heatmap(patch, x=x, y=y, title="Patch Type")
    plot_heatmap(DBHc, x=x, y=y, title="Diameter at Breast Height")
    plt.show()



if __name__ == "__main__":
    generate_canopy()
